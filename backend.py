
# -*- coding: utf-8 -*-
"""Draft.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1JeEXxTzKYwB_uraxC4vlsq6IwYfs1qhh
"""

import getpass
import os
import logging
logging.getLogger("langchain_google_genai.chat_models").setLevel(logging.ERROR)
if "GOOGLE_API_KEY" not in os.environ:
    os.environ["GOOGLE_API_KEY"] = "AIzaSyD_K258YPnc7_GuDDtQ5kHFfe4SO2cmpYY"
from langchain.text_splitter import RecursiveCharacterTextSplitter
from langchain_google_genai import ChatGoogleGenerativeAI

from langchain_google_genai import GoogleGenerativeAIEmbeddings
import chromadb
# 1) Khởi raw embedder cho Gemini text-embedding-004 (768-dim)
raw_embedder = GoogleGenerativeAIEmbeddings(model="models/text-embedding-004")

# 2) Wrapper đúng interface (tham số phải tên “input”)aa
class ChromaEmbeddingWrapper768:
    def __init__(self, embedder, name: str):
        self.embedder = embedder
        self._name = name

    def __call__(self, input: list[str]) -> list[list[float]]:
        # ChromaDB sẽ gọi wrapper(self, input)
        return self.embedder.embed_documents(input)

    def name(self) -> str:
        return self._name

# Tạo instance wrapper
wrapper_768 = ChromaEmbeddingWrapper768(
    raw_embedder,
    name="text-embedding-004"   # tên model embedding chính xác
)

# 3) Kết nối Chroma
client = chromadb.Client()

pdf_collection = client.get_or_create_collection(
    name="pdf_auto_khdl",
    embedding_function=wrapper_768
)
excel_collection = client.get_or_create_collection(
    name="excel_manual_khdl",
    embedding_function=wrapper_768
)

pdf_folder = "./BKI/Auto chunk"
pdf_files = [f for f in os.listdir(pdf_folder) if f.endswith(".pdf")]

#Auto chunking
from langchain.text_splitter import RecursiveCharacterTextSplitter
from langchain.document_loaders import (
TextLoader,
UnstructuredPDFLoader,
PyPDFLoader
)
from langchain_google_genai import GoogleGenerativeAIEmbeddings
splitter = RecursiveCharacterTextSplitter(
    chunk_size=800,             # tăng lên để chứa đủ 1-2 đoạn ý liền mạch
    chunk_overlap=100,          # vừa phải, đủ để không mất ngữ cảnh
    separators=["\n\n", "\n", ".", "!", "?", " ", ""]
)
for file in pdf_files:
    file_path = os.path.join(pdf_folder, file)  #lấy địa chỉ cụ thể của từng file trong folder
    loader = PyPDFLoader(file_path)
    pages = loader.load()  # Mỗi trang là 1 Document

    full_text = "\n".join([page.page_content for page in pages])#Nối các trang trong file thành một đoạn
    chunks = splitter.split_text(full_text)  # → list[str]
    doc_id_base = "to_roi_KHDL_BMT_2025" # Tên file không đuôi

    documents = os.path.splitext(file)[0]
    metadatas = [{"source": doc_id_base, "content": chunk} for chunk in chunks]
    to_embed = [f"{documents} — {meta['content']}" for meta in metadatas]
    embeddings = raw_embedder.embed_documents(to_embed)
    ids = [f"{documents}_chunk_{i}" for i in range(len(chunks))]
     # Nạp vào collection
    pdf_collection.add(
        documents=[documents] * len(chunks),  # tên file lặp lại
        metadatas=metadatas,
        embeddings=embeddings,
        ids=ids
    )

#Manual chunking
import pandas as pd
from langchain_google_genai import GoogleGenerativeAIEmbeddings

# Đọc Excel
df = pd.read_excel("./BKI/Manual chunk/Data.xlsx")  # Hoặc đúng đường dẫn Colab của bạn

# Hàm xử lý gạch đầu dòng nếu cần (không bắt buộc)
def format_bullets(raw: str) -> str:
    items = [s.strip() for s in str(raw).split(";") if s.strip()]
    return "\n".join(f"+ {it}" for it in items)

for idx, row in df.iterrows():
    # a) Tạo document (tiêu đề) và content (nội dung đã format)
    documents = f"- {row['Doccument']}".strip()
    content = format_bullets(row["Content"])
    source = str(row["Source"])
    to_embed = [f"{documents} — {content}"]

    # b) Embed ngay chuỗi đó (list độ dài = 1)
    embedding = raw_embedder.embed_documents(to_embed)

    # c) Add vào collection
    excel_collection.add(
        documents=[documents],
        metadatas=[{"source": source, "content": content}],
        embeddings=embedding,
        ids=[f"doc{idx+1}"]
    )

#tính các điểm thành phần để tính điểm học lực
def calculate_nang_luc(math_score: float, other_score_sum: float) -> dict:
    """
    Điểm năng lực = (math_score * 2 + other_score_sum) / 15
    """
    weighted = math_score * 2 + other_score_sum
    nang_luc = round(weighted / 15, 2)
    return {"nang_luc_score": nang_luc}


def calculate_thpt_test_converted(total_three_subjects: float) -> dict:
    """
    Điểm TNTHPT quy đổi = (Tổng điểm thi 3 môn) / 3 * 10
    """
    converted = round(total_three_subjects / 3 * 10, 2)
    return {"thpt_test_converted": converted}


def calculate_hocba_converted(avg_grade_three_years: float) -> dict:
    """
    Điểm học THPT quy đổi = Trung bình cộng điểm TB 3 năm × 10
    """
    converted = round(avg_grade_three_years * 10, 2)
    return {"hocba_converted": converted}

#tính điểm học lực
def calculate_academic_score(math_score: float,
                             other_score_sum: float,
                             total_three_subjects: float,
                             avg_grade_three_years: float) -> dict:
    """
    Điểm học lực = Điểm năng lực * 0.7
                 + Điểm TNTHPT quy đổi * 0.2
                 + Điểm học THPT quy đổi * 0.1
    Trả về dict bao gồm các giá trị trung gian và kết quả cuối.
    """
    # Gọi các hàm con đã định nghĩa trước
    nang_luc = calculate_nang_luc(math_score, other_score_sum)["nang_luc_score"]
    thpt_converted = calculate_thpt_test_converted(total_three_subjects)["thpt_test_converted"]
    hocba_converted = calculate_hocba_converted(avg_grade_three_years)["hocba_converted"]

    # Tính Điểm học lực theo tỷ lệ
    academic = round(nang_luc * 0.7 + thpt_converted * 0.2 + hocba_converted * 0.1, 2)

    return {
        "academic_score": academic,
        "nang_luc_score": nang_luc,
        "thpt_test_converted": thpt_converted,
        "hocba_converted": hocba_converted
    }

#tính điểm cộng
def calculate_bonus(academic_score: float,
                    performance_bonus: float) -> dict:
    """
    - Giới hạn performance_bonus tối đa 10.
    - Nếu academic_score + raw_bonus < 100 -> bonus = raw_bonus
      Ngược lại -> bonus = 100 - academic_score
    """
    raw_bonus = min(performance_bonus, 10.0)
    if academic_score + raw_bonus < 100.0:
        bonus = raw_bonus
    else:
        bonus = max(0.0, 100.0 - academic_score)
    return {"bonus": round(bonus, 2)}

#tính điểm ưu tiên
def calculate_priority(academic_score: float,
                       bonus: float,
                       priority_group_score: float) -> dict:
    """
    - priority_converted = (priority_group_score / 3) * 10
    - Nếu academic_score + bonus < 75 -> priority = priority_converted
      Ngược lại -> priority = ((100 - academic_score - bonus)/25) * priority_converted
    - Làm tròn 2 chữ số
    """
    priority_converted = (priority_group_score / 3.0) * 10.0
    if academic_score + bonus < 75.0:
        priority = priority_converted
    else:
        priority = round((100.0 - academic_score - bonus) / 25.0 * priority_converted, 2)
    return {"priority": round(priority, 2)}

#tính điểm xét tuyển
def calculate_admission_score(math_score: float,
                              other_score_sum: float,
                              total_three_subjects: float,
                              avg_grade_three_years: float,
                              performance_bonus: float,
                              priority_group_score: float) -> dict:
    """
    Tính Điểm xét tuyển trên thang 100 bao gồm:
      1) Điểm học lực (70% năng lực + 20% TNTHPT quy đổi + 10% học bạ quy đổi)
      2) Điểm cộng thành tích (tối đa 10, không vượt 100)
      3) Điểm ưu tiên (quy đổi & điều chỉnh theo <75 / ≥75)
    Trả về dict với:
      - academic_score, bonus, priority, admission_score
      - cùng các điểm trung gian: nang_luc_score, thpt_test_converted, hocba_converted
    """
    # 1) Academic score
    acad = calculate_academic_score(
        math_score, other_score_sum,
        total_three_subjects, avg_grade_three_years
    )
    academic_score = acad["academic_score"]

    # 2) Bonus
    bonus = calculate_bonus(academic_score, performance_bonus)["bonus"]

    # 3) Priority
    priority = calculate_priority(academic_score, bonus, priority_group_score)["priority"]

    # 4) Total admission score
    admission_score = round(academic_score + bonus + priority, 2)

    return {
        "admission_score": admission_score,
        "academic_score": academic_score,
        "nang_luc_score": acad["nang_luc_score"],
        "thpt_test_converted": acad["thpt_test_converted"],
        "hocba_converted": acad["hocba_converted"],
        "bonus": bonus,
        "priority": priority
    }

# Định nghĩa các Tool sử dụng các hàm có sẵn
from langchain.tools import Tool
tools = [
    Tool(
        name="calculate_nang_luc",
        func=calculate_nang_luc,
        description="Tính Điểm năng lực = (math_score * 2 + other_score_sum) / 15",
        args_schema={
            "math_score": {"type": "number", "description": "Điểm ĐGNL môn Toán", "required": True},
            "other_score_sum": {"type": "number", "description": "Tổng điểm ĐGNL các môn còn lại", "required": True}
        }
    ),
    Tool(
        name="calculate_hocba_converted",
        func=calculate_hocba_converted,
        description="Tính Điểm học THPT quy đổi = Trung bình cộng điểm TB 3 năm × 10.",
        args_schema={
            "avg_grade_three_years": {"type": "number", "description": "Trung bình cộng điểm TB lớp 10, 11, 12 của các môn trong tổ hợp", "required": True}
        }
    ),
    Tool(
        name="calculate_thpt_test_converted",
        func=calculate_thpt_test_converted,
        description="Tính Điểm TNTHPT quy đổi = (Tổng điểm thi 3 môn trong tổ hợp) / 3 × 10.",
        args_schema={
            "total_three_subjects": {"type": "number", "description": "Tổng điểm thi THPT của 3 môn trong tổ hợp", "required": True}
        }
    ),
    Tool(
        name="calculate_academic_score",
        func=calculate_academic_score,
        description="Tính Điểm học lực trên thang 100: 70% từ Điểm năng lực, 20% từ Điểm TNTHPT quy đổi, 10% từ Điểm học bạ quy đổi.",
        args_schema={
            "math_score": {"type": "number", "description": "Điểm ĐGNL môn Toán", "required": True},
            "other_score_sum": {"type": "number", "description": "Tổng điểm ĐGNL các môn còn lại", "required": True},
            "total_three_subjects": {"type": "number", "description": "Tổng điểm thi THPT của 3 môn trong tổ hợp", "required": True},
            "avg_grade_three_years": {"type": "number", "description": "Trung bình cộng điểm TB 3 năm các môn trong tổ hợp", "required": True}
        }
    ),
    Tool(
        name="calculate_bonus",
        func=calculate_bonus,
        description="Tính Điểm cộng thành tích (tối đa 10 điểm, không vượt 100 điểm khi cộng với Điểm học lực).",
        args_schema={
            "academic_score": {"type": "number", "description": "Điểm học lực trên thang 100", "required": True},
            "performance_bonus": {"type": "number", "description": "Tổng điểm cộng thành tích ban đầu (tối đa 10)", "required": True}
        }
    ),
    Tool(
        name="calculate_priority",
        func=calculate_priority,
        description="Tính Điểm ưu tiên theo quy tắc: nếu academic_score+bonus <75 dùng nguyên, ngược lại phải điều chỉnh.",
        args_schema={
            "academic_score": {"type": "number", "description": "Điểm học lực đã tính", "required": True},
            "bonus": {"type": "number", "description": "Điểm cộng thành tích đã điều chỉnh", "required": True},
            "priority_group_score": {"type": "number", "description": "Điểm ưu tiên (khu vực/đối tượng) ban đầu trên thang 0–2.75", "required": True}
        }
    ),
    Tool(
        name="calculate_admission_score",
        func=calculate_admission_score,
        description="Tính Điểm xét tuyển trên thang 100, gộp điểm học lực, điểm cộng thành tích và điểm ưu tiên.",
        args_schema={
            "math_score": {"type": "number", "description": "Điểm ĐGNL môn Toán", "required": True},
            "other_score_sum": {"type": "number", "description": "Tổng điểm ĐGNL các môn còn lại", "required": True},
            "total_three_subjects": {"type": "number", "description": "Tổng điểm thi THPT của 3 môn trong tổ hợp", "required": True},
            "avg_grade_three_years": {"type": "number", "description": "Trung bình cộng điểm TB lớp 10,11,12 các môn trong tổ hợp", "required": True},
            "performance_bonus": {"type": "number", "description": "Điểm cộng thành tích ban đầu (tối đa 10)", "required": True},
            "priority_group_score": {"type": "number", "description": "Điểm ưu tiên (khu vực/đối tượng) ban đầu trên thang 0–2.75", "required": True}
        }
    )
]

llm = ChatGoogleGenerativeAI(
    model="gemini-2.5-flash-lite-preview-06-17",
    temperature=0,
    max_tokens=None,
    timeout=None,
    max_retries=2,
    # other params...
)

from langchain.schema import Document, HumanMessage, SystemMessage, AIMessage
import re
# Hàm truy vấn ChromaDB
def query_chroma(collection, query: str, top_k: int = 3) -> list[dict]:
    # Embed câu hỏi
    query_embedding = raw_embedder.embed_query(query)

    # Truy vấn collection
    results = collection.query(
        query_embeddings=[query_embedding],
        n_results=top_k
    )

    # Format kết quả
    return [
        [doc, {"content": meta["content"]}]
        for doc, meta in zip(results["documents"][0], results["metadatas"][0])
    ]
def process_function_call(query: str, llm_with_tools) -> str:
    # System Prompt rõ ràng với ví dụ cụ thể messages

    messages = [
        SystemMessage(content="""
        Bạn là chatbot tính toán điểm tuyển sinh. Nhiệm vụ: nhận diện công cụ phù hợp và trích xuất tham số chính xác từ câu hỏi.

        Hướng dẫn:
        - Xác định công cụ dựa trên thông tin trong câu hỏi.
        - Trích xuất tham số theo tên chính xác: math_score_ other_score_sum, total_three_subjects, avg_grade_three_years, performance_bonus, priority_group_score.
        - Nếu thiếu tham số, trả về thông báo yêu cầu cung cấp đủ thông tin.

        Ví dụ:
        1. 'Tính điểm năng lực với điểm Toán 8.5 và tổng các môn khác 16'
           → Công cụ: calculate_nang_luc, tham số: math_score=8.5, other_score_sum=16.0
        2. 'Tính điểm thi tốt nghiệp quy đổi với tổng điểm 3 môn là 27'
           → Công cụ: calculate_thpt_test_converted, tham số: total_three_subjects=27.0
        3. 'Tính điểm học bạ quy đổi với trung bình 3 năm là 8.5'
           → Công cụ: calculate_hocba_converted, tham số: avg_grade_three_years=8.5
        4. 'Tính điểm học lực với điểm Toán 8, tổng các môn khác 15, tổng điểm thi THPT 24, trung bình 3 năm 8'
           → Công cụ: calculate_academic_score, tham số: math_score=8.0, other_score_sum=15.0, total_three_subjects=24.0, avg_grade_three_years=8.0
        5. 'Tính điểm cộng với điểm học lực 80 và điểm thành tích 5'
           → Công cụ: calculate_bonus, tham số: academic_score=80.0, performance_bonus=5.0
        6. 'Tính điểm ưu tiên với điểm học lực 80, điểm thành tích 5, điểm ưu tiên nhóm 2'
           → Công cụ: calculate_priority, tham số: academic_score=80.0, bonus=5.0, priority_group_score=2.0
        7. 'Tính điểm xét tuyển với điểm Toán 8, tổng các môn khác 15, tổng điểm thi THPT 24, trung bình 3 năm 8, điểm thành tích 5, điểm ưu tiên nhóm 2'
           → Công cụ: calculate_admission_score, tham số: math_score=8.0, other_score_sum=15.0, total_three_subjects=24.0, avg_grade_three_years=8.0, performance_bonus=5.0, priority_group_score=2.0

        Nếu không trích xuất được đủ tham số, trả về: 'Vui lòng cung cấp đủ thông tin (ví dụ: điểm Toán, tổng điểm các môn khác, tổng điểm thi THPT, trung bình 3 năm, điểm thành tích, điểm ưu tiên).'
        """),
        HumanMessage(content=query)
    ]

    response = llm_with_tools.invoke(messages)

    if response.tool_calls:
        tool_call = response.tool_calls[0]
        tool_name = tool_call['name']
        tool_args = tool_call['args']

        # Tìm công cụ tương ứng
        for tool in tools:
            if tool.name == tool_name:
                # Lấy danh sách tham số bắt buộc từ args_schema
                required_params = tool.args_schema.get("required", []) if isinstance(tool.args_schema, dict) else []

                # Kiểm tra xem có đủ tham số không
                if not tool_args or not all(param in tool_args for param in required_params):
                    query_lower = query.lower()
                    tool_args = {}

                    if tool_name == "calculate_nang_luc":
                        math_match = re.search(r"điểm\s*toán\s*[=:]?\s*(\d+\.?\d*)", query_lower)
                        other_match = re.search(r"tổng\s*(?:điểm\s*)?các\s*môn\s*khác\s*[=:]?\s*(\d+\.?\d*)", query_lower)
                        if math_match and other_match:
                            tool_args = {
                                "math_score": float(math_match.group(1)),
                                "other_score_sum": float(other_match.group(1))
                            }
                    elif tool_name == "calculate_thpt_test_converted":
                        score_match = re.search(r"tổng\s*điểm\s*(?:thi\s*)?(?:ba\s*môn)?\s*[=:]?\s*(\d+\.?\d*)", query_lower)
                        if score_match:
                            tool_args = {"total_three_subjects": float(score_match.group(1))}
                    elif tool_name == "calculate_hocba_converted":
                        avg_match = re.search(r"trung\s*bình\s*3\s*năm\s*[=:]?\s*(\d+\.?\d*)", query_lower)
                        if avg_match:
                            tool_args = {"avg_grade_three_years": float(avg_match.group(1))}
                    elif tool_name == "calculate_academic_score":
                        math_match = re.search(r"điểm\s*toán\s*[=:]?\s*(\d+\.?\d*)", query_lower)
                        other_match = re.search(r"tổng\s*(?:điểm\s*)?các\s*môn\s*khác\s*[=:]?\s*(\d+\.?\d*)", query_lower)
                        thpt_match = re.search(r"tổng\s*điểm\s*thi\s*thpt\s*[=:]?\s*(\d+\.?\d*)", query_lower)
                        avg_match = re.search(r"trung\s*bình\s*3\s*năm\s*[=:]?\s*(\d+\.?\d*)", query_lower)
                        if all([math_match, other_match, thpt_match, avg_match]):
                            tool_args = {
                                "math_score": float(math_match.group(1)),
                                "other_score_sum": float(other_match.group(1)),
                                "total_three_subjects": float(thpt_match.group(1)),
                                "avg_grade_three_years": float(avg_match.group(1))
                            }
                    elif tool_name == "calculate_bonus":
                        academic_match = re.search(r"điểm\s*học\s*lực\s*[=:]?\s*(\d+\.?\d*)", query_lower)
                        bonus_match = re.search(r"điểm\s*thành\s*tích\s*[=:]?\s*(\d+\.?\d*)", query_lower)
                        if academic_match and bonus_match:
                            tool_args = {
                                "academic_score": float(academic_match.group(1)),
                                "performance_bonus": float(bonus_match.group(1))
                            }
                    elif tool_name == "calculate_priority":
                        academic_match = re.search(r"điểm\s*học\s*lực\s*[=:]?\s*(\d+\.?\d*)", query_lower)
                        bonus_match = re.search(r"điểm\s*thành\s*tích\s*[=:]?\s*(\d+\.?\d*)", query_lower)
                        priority_match = re.search(r"điểm\s*ưu\s*tiên\s*(?:nhóm)?\s*[=:]?\s*(\d+\.?\d*)", query_lower)
                        if all([academic_match, bonus_match, priority_match]):
                            tool_args = {
                                "academic_score": float(academic_match.group(1)),
                                "bonus": float(bonus_match.group(1)),
                                "priority_group_score": float(priority_match.group(1))
                            }
                    elif tool_name == "calculate_admission_score":
                        math_match = re.search(r"điểm\s*toán\s*[=:]?\s*(\d+\.?\d*)", query_lower)
                        other_match = re.search(r"tổng\s*(?:điểm\s*)?các\s*môn\s*khác\s*[=:]?\s*(\d+\.?\d*)", query_lower)
                        thpt_match = re.search(r"tổng\s*điểm\s*thi\s*thpt\s*[=:]?\s*(\d+\.?\d*)", query_lower)
                        avg_match = re.search(r"trung\s*bình\s*3\s*năm\s*[=:]?\s*(\d+\.?\d*)", query_lower)
                        bonus_match = re.search(r"điểm\s*thành\s*tích\s*[=:]?\s*(\d+\.?\d*)", query_lower)
                        priority_match = re.search(r"điểm\s*ưu\s*tiên\s*(?:nhóm)?\s*[=:]?\s*(\d+\.?\d*)", query_lower)
                        if all([math_match, other_match, thpt_match, avg_match, bonus_match, priority_match]):
                            tool_args = {
                                "math_score": float(math_match.group(1)),
                                "other_score_sum": float(other_match.group(1)),
                                "total_three_subjects": float(thpt_match.group(1)),
                                "avg_grade_three_years": float(avg_match.group(1)),
                                "performance_bonus": float(bonus_match.group(1)),
                                "priority_group_score": float(priority_match.group(1))
                            }

                try:
                    # Kiểm tra xem tất cả tham số bắt buộc có trong tool_args không
                    if tool_args and all(param in tool_args for param in required_params):
                        result = tool.func(**tool_args)
                        if tool_name == "calculate_nang_luc":
                            return f"Điểm năng lực: {result['nang_luc_score']}"
                        elif tool_name == "calculate_thpt_test_converted":
                            return f"Điểm thi THPT quy đổi: {result['thpt_test_converted']}"
                        elif tool_name == "calculate_hocba_converted":
                            return f"Điểm học bạ quy đổi: {result['hocba_converted']}"
                        elif tool_name == "calculate_academic_score":
                            return (f"Điểm học lực: {result['academic_score']}\n"
                                    f"Chi tiết: Điểm năng lực = {result['nang_luc_score']}, "
                                    f"Điểm thi THPT quy đổi = {result['thpt_test_converted']}, "
                                    f"Điểm học bạ quy đổi = {result['hocba_converted']}")
                        elif tool_name == "calculate_bonus":
                            return f"Điểm cộng: {result['bonus']}"
                        elif tool_name == "calculate_priority":
                            return f"Điểm ưu tiên: {result['priority']}"
                        elif tool_name == "calculate_admission_score":
                            return (f"Điểm xét tuyển: {result['admission_score']}\n"
                                    f"Chi tiết: Điểm học lực = {result['academic_score']}, "
                                    f"Điểm năng lực = {result['nang_luc_score']}, "
                                    f"Điểm thi THPT quy đổi = {result['thpt_test_converted']}, "
                                    f"Điểm học bạ quy đổi = {result['hocba_converted']}, "
                                    f"Điểm cộng = {result['bonus']}, "
                                    f"Điểm ưu tiên = {result['priority']}")
                    else:
                        return (f"Lỗi: Vui lòng cung cấp đủ thông tin cho {tool_name}. "
                                f"Yêu cầu: {', '.join(required_params)}. "
                                f"Ví dụ: '{tool.description.split('.')[0]}'.")
                except Exception as e:
                    return f"Lỗi khi gọi tool: {str(e)}"
        return f"Không tìm thấy tool: {tool_name}"
    else:
        return "Không nhận diện được công cụ. Vui lòng kiểm tra câu hỏi. Ví dụ: 'Tính điểm xét tuyển với điểm Toán 8, tổng các môn khác 15, tổng điểm thi THPT 24, trung bình 3 năm 8, điểm thành tích 5, điểm ưu tiên nhóm 2'."
# Prompt template cho intent classification
intent_prompt_template = """
Bạn là một chatbot hỗ trợ tư vấn tuyển sinh. Phân loại ý định (intent) của câu hỏi sau thành một trong ba loại:
- `auto_chunk`: Câu hỏi liên quan đến thông tin từ PDF, như quy định, quy trình xét tuyển.
- `manual_chunk`: Câu hỏi liên quan đến thông tin từ danh sách Excel, như tiêu chí, danh mục cụ thể.
- `calculate_score`: Câu hỏi yêu cầu tính điểm xét tuyển hoặc các điểm thành phần (như điểm năng lực, học bạ, ưu tiên).

Câu hỏi: "{query}"

**Output**:
Chỉ trả về tên intent (`auto_chunk`, `manual_chunk`, hoặc `calculate_score`). Không giải thích.
"""
# Gắn tools vào model
llm_with_tools = llm.bind_tools(tools)
def classify_intent(query: str) -> str:
    # Tạo nội dung message theo định dạng chuẩn của langchain
    prompt = intent_prompt_template.format(query=query)
    messages = [HumanMessage(content=prompt)]

    # Gọi mô hình
    response = llm_with_tools.invoke(messages)

    # Truy cập nội dung từ response (dùng .content vì response là AIMessage)
    if isinstance(response, AIMessage) and response.content:
        return response.content.strip()
    return "unknown"
def process_query(query: str, llm_with_tools) -> str:
    # 1. Phân loại intent
    intent = classify_intent(query)

    # 2. Xử lý theo intent
    if intent == "auto_chunk":
        # Truy vấn pdf_collection
        results = query_chroma(pdf_collection, query)
        print(results)
        if results:
          msgs = [
            {"author": "system", "content": f"Tôi là trợ lý PDF. Thông tin:\n{results}"},
            {"author": "user",   "content": query},
        ]
        return llm.predict(msgs).strip()
        return "Không tìm thấy thông tin phù hợp trong PDF."

    elif intent == "manual_chunk":
        # Truy vấn excel_collection
        results = query_chroma(excel_collection, query)
        print(results)
        if results:
          msgs = [
            {"author": "system", "content": f"Tôi là trợ lý PDF. Thông tin:\n{results}"},
            {"author": "user",   "content": query},
        ]
        return llm.predict(msgs).strip()
        return "Không tìm thấy thông tin phù hợp trong Excel."
    elif intent == "calculate_score":
        return  process_function_call(query, llm_with_tools)
    return "Không hiểu câu hỏi. Vui lòng hỏi lại."
if __name__ == "__main__":
    print("🌟 Chào bạn! Gõ 'exit' hoặc 'quit' để kết thúc phiên làm việc.\n")
    while True:
        query = input("Bạn: ").strip()
        if query.lower() in ("exit", "quit"):
            print("Chatbot: Hẹn gặp lại! 👋")
            break

        # 1. Phân loại intent
        intent = classify_intent(query)
        # 2. Xử lý theo intent
        if intent == "auto_chunk":
            results = query_chroma(pdf_collection, query)
            if results:
                msgs = [
                    {"author": "system", "content": f"Tôi là trợ lý PDF. Thông tin:\n{results}"},
                    {"author": "user",   "content": query},
                ]
                answer = llm.predict(msgs).strip()
            else:
                answer = "Không tìm thấy thông tin phù hợp trong PDF."
        elif intent == "manual_chunk":
            results = query_chroma(excel_collection, query)
            if results:
                msgs = [
                    {"author": "system", "content": f"Tôi là trợ lý Excel. Thông tin:\n{results}"},
                    {"author": "user",   "content": query},
                ]
                answer = llm.predict(msgs).strip()
            else:
                answer = "Không tìm thấy thông tin phù hợp trong Excel."
        elif intent == "calculate_score":
            answer = process_function_call(query, llm_with_tools)
        else:
            answer = "Không hiểu câu hỏi. Vui lòng hỏi lại."

        print(f"Chatbot: {answer}\n")
